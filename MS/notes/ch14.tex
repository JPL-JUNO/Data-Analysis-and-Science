\chapter{响应图\label{ch14}}
\section{响应式执行的逐步浏览}
为了解释响应式执行的过程，我们将使用\autoref{fig14-1}所示的图形。它包含三个响应性输入、三个响应性表达式和三个输出。响应式输入和表达式统称为响应式生产者；响应式表达式和输出是响应式消费者。

\figures{fig14-1}{一个虚构应用程序的完整响应图，包含三个输入、三个响应表达式和三个输出。}
组件之间的连接是有方向的，箭头指示响应的方向。这一方向可能会让你感到惊讶，因为很容易想到消费者依赖于一个或多个生产者。然而，很快你就会发现响应流在相反方向上的建模更加准确。
\section{会话开始}
\autoref{fig14-2}显示了应用程序启动且服务器功能首次执行后的响应图。

\figures{fig14-2}{应用程序加载后的初始状态。 对象之间没有连接，所有响应式表达式都无效（灰色）。 有六个响应性消费者和六个响应性生产者。}

该图中传达了三个重要信息：
\begin{itemize}
    \item 元素之间没有联系，因为 Shiny对响应之间的关系没有先验知识。
    \item 所有响应式表达式和输出都处于起始状态，无效（灰色），这意味着它们尚未运行。
    \item 响应输入已准备就绪（绿色），表明它们的值可用于计算。
\end{itemize}

\subsection{执行开始}
现在我们开始执行阶段，如\autoref{fig14-3}所示。
\figures{fig14-3}{Shiny 开始执行任意观察者/输出，颜色为橙色。}
在此阶段，Shiny 选择一个无效的输出并开始执行它（橙色）。你可能想知道 Shiny 如何决定执行哪些无效输出。简而言之，你应该表现得好像它是随机的：你的观察者和输出不应该关心它们执行的顺序，因为它们被设计为独立运行。
\subsection{读取响应式表达式}
执行输出可能需要来自响应性的值，如图14.4所示。
\figures{fig14-4}{输出需要响应式表达式的值，因此它开始执行该表达式。}
读取响应式会以两种方式改变图表：
\begin{itemize}
    \item 响应式表达式还需要开始计算其值（变成橙色）。请注意，输出仍在计算：它正在等待响应式表达式返回其值，以便其自身的执行可以继续，就像 R 中的常规函数​​调用一样。

    \item Shiny 记录了输出和响应表达式之间的关系（即我们画了一个箭头）。箭头的方向很重要：表达式记录了它被输出使用；输出不记录它使用该表达式。这是一个微妙的区别，但当你了解失效时，其重要性将变得更加清晰。
\end{itemize}
\subsection{读取输入}
这个特定的响应式表达式恰好读取响应式输入。再次建立了依赖/依赖关系，因此在图14.5中我们添加了另一个箭头。

\figures{fig14-5}{响应表达式也读取响应值，因此我们添加另一个箭头。}
与响应式表达式和输出不同，响应式输入不需要执行任何内容，因此它们可以立即返回。
\subsection{响应式表达式完成}
在我们的示例中，响应式表达式读取另一个响应式表达式，后者又读取另一个输入。我们将跳过这些步骤的详细描述，因为它们是我们已经描述过的内容的重复，并直接跳至\autoref{fig14-6}。
\figures{fig14-6}{响应式表达式已完成计算，因此变为绿色。}
现在响应式表达式已完成执行，它会变成绿色，表明它已准备就绪。它会缓存结果，因此不需要重新计算，除非其输入发生变化。
\subsection{输出完成}
现在响应式表达式已经返回了它的值，输出可以完成执行，并将颜色更改为绿色，如\autoref{fig14-7}所示。
\subsection{执行下一个输出}
\subsection{执行完成，输出刷新}
\section{输入变化}
上一步结束时，我们的 Shiny 会话处于完全空闲状态。现在想象一下应用程序的用户更改滑块的值。这会导致浏览器向服务器函数发送一条消息，指示 Shiny 更新相应的响应式输入。这将启动\textbf{无效阶段}，该阶段由三个部分组成：使输入无效、通知依赖项，然后删除现有连接。
\subsection{使输入无效}
\subsection{通知依赖关系}
现在，我们沿着之前绘制的箭头，将每个节点着色为灰色，并将我们遵循的箭头着色为浅灰色。得出\autoref{fig14-11}。
\subsection{删除关系\label{14.4.3}}
接下来，每个无效的响应表达式和输出都会“擦除”所有进出它的箭头，产生\autoref{fig14-12}，并完成无效阶段。

从节点发出的箭头是一次性通知，将在下次值更改时触发。现在他们已经开火了，他们的目的已经达到，我们可以消灭他们了。

不太明显的是为什么我们删除进入无效节点的箭头，即使它们来自的节点没有无效。虽然这些箭头代表尚未触发的通知，但失效的节点不再关心它们：响应性消费者只关心通知，以便使自己失效，而这已经发生了。

我们如此看重这些关系，现在却把它们抛弃了，这似乎有些反常！但这是 Shiny 响应式编程模型的关键部分：尽管这些特定的箭头很重要，但它们现在已经过时了。确保我们的图表保持准确的唯一方法是在箭头变得陈旧时删除它们，并让 Shiny 在它们重新执行时重新发现这些节点周围的关系。我们将在\nameref{14.5}中回到这个重要的主题。
\subsection{重新执行}
\section{动态性\label{14.5}}
在\nameref{14.4.3}中，你了解到 Shiny“忘记”了它花费大量精力记录的响应组件之间的连接。这使得 Shiny 具有响应性动态，因为它可以在你的应用程序运行时发生变化。
\section{总结}
在本章中，已经准确了解了响应图的运作方式。特别是，第一次了解了失效阶段，该阶段不会立即导致重新计算，而是将响应式消费者标记为无效，以便在需要时重新计算它们。失效周期也很重要，因为它清除了以前发现的依赖关系，以便可以自动重新发现它们，从而使响应式图形变得动态。