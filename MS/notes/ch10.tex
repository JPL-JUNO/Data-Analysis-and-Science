\chapter{动态 UI\label{ch10}}
创建动态用户界面有以下三种关键技术：
\begin{itemize}
    \item 使用 update 函数族修改输入控件的参数。
    \item 用于 tabsetPanel() 有条件地显示和隐藏部分用户界面。
    \item 使用 uiOutput() 和 renderUI() 通过代码生成用户界面的选定部分。
\end{itemize}

这三个工具使你能够通过修改输入和输出来响应用户。我将演示一些更有用的方法来应用它们，但最终你只会受到你的创造力的限制。同时，这些工具可能会使你的应用程序更加难以推理，因此请谨慎部署它们，并始终努力使用最简单的技术来解决你的问题。
\section{更新输入}
每个输入控件都与一个\textbf{更新函数}配对，该函数允许你在创建控件后对其进行修改。更新函数看起来与其他 Shiny 函数略有不同：它们都将输入的名称（作为字符串）作为 inputId 参数。其余参数对应于输入构造函数的参数，可以在创建后进行修改。

\subsection{分层选择框}
一个特别重要的应用是通过逐步过滤，可以更轻松地从一长串可能的选项中进行选择。这通常是“分层选择框”的问题。更新功能的一个更复杂但特别有用的应用是允许跨多个类别进行交互式钻取。
\subsection{循环引用}
如果你想使用更新函数来更改输入的当前 value，那么我们需要讨论一个重要问题。从 Shiny 的角度来看，使用更新功能进行修改 value 与用户通过单击或键入来修改值没有什么不同。这意味着更新函数可以以与人类完全相同的方式触发反应性更新。这意味着你现在已经超出了纯反应式编程的范围，并且你需要开始担心循环引用和无限循环。
\subsection{相互关联的输入}
当应用程序中有多个“事实来源”时，很容易出现循环引用。
\section{动态可见性}
复杂性的下一步是有选择地显示和隐藏部分 UI。如果你了解一点 JavaScript 和 CSS，还有更复杂的方法，但有一种不需要任何额外知识的有用技术：使用选项卡集隐藏可选 UI。这是一个聪明的技巧，允许你根据需要显示和隐藏 UI，而无需从头开始重新生成它。

这里有两个主要想法：
\begin{itemize}
    \item 使用带有隐藏选项卡的选项卡集面板。
    \item updateTabsetPanel() 用于从服务器切换选项卡。
\end{itemize}
\subsection{条件性的用户界面}
\subsection{向导界面}
你还可以使用这个想法来创建一个“向导”，这是一种界面，可以通过将大量信息分布在多个页面上来更轻松地收集信息。
\section{使用代码创建 UI}
\begin{itemize}
    \item uiOutput() 在你的 ui 上插入一个占位符。 这会留下一个“漏洞”，你的服务器代码可以稍后填充。
    \item renderUI() 在 server() 内部被调用以使用动态生成的 UI 填充占位符。
\end{itemize}
\subsection{入门}
你会注意到应用程序加载后只需要几分之一秒的时间即可显示。这是因为它是响应式的：应用程序必须加载、触发响应式事件，该事件调用服务器函数，生成要插入到页面中的 HTML。这是 renderUI() 的缺点之一；过度依赖它可能会导致用户界面滞后。

这种方法还有另一个问题：当你更改控件时，你会丢失当前选择的值。维护现有状态是使用代码创建 UI 的一大挑战。这就是有选择地显示和隐藏 UI 是一种更好的方法（如果它适合你）的原因之一 - 因为你没有销毁和重新创建控件，因此不需要执行任何操作来保留值。但是，在许多情况下，我们可以通过将新输入的 value 值设置为现有控件的当前值来解决问题。
\subsection{多重控制}
当你生成任意数量或类型的控件时，动态 UI 最有用。这意味着你将使用代码生成 UI，我建议使用函数式编程来完成此类任务。
\subsection{对话框}
在我们结束之前，想提一下相关的技术：对话框。你已经在\nameref{subsection841}中看到了它们，其中对话框的内容是固定的文本字符串。但因为 modalDialog() 是从服务器函数内部调用的，所以你实际上可以像 renderUI() 一样动态创建内容. 如果你想迫使用户在继续常规应用程序流程之前做出某些决定，那么这是一项非常有用的技术。