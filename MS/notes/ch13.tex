\chapter{为什么是响应性？\label{ch13}}
\section{介绍}
\section{为什么我们需要响应式编程？}
响应式编程是一种编程风格，重点关注随时间变化的值以及依赖于这些值的计算和操作。响应性对于 Shiny 应用程序来说很重要，因为它们是交互式的：用户更改输入控件（拖动滑块、输入文本框、检查复选框等），最终导致逻辑在服务器上运行（读取 CSV、子集数据、拟合模型等）导致输出更新（绘图重绘、表格更新……）。这与大多数 R 代码有很大不同，大多数 R 代码通常处理相当静态的数据。

为了让闪亮的应用程序发挥最大作用，我们需要响应式表达式和输出，当且仅当它们的输入发生变化时才进行更新。我们希望输出与输入保持同步，同时确保我们不会做不必要的工作。为了了解为什么响应性在这里如此有用，我们将尝试解决一个没有响应性的简单问题。
\subsection{为什么不能使用变量？}
从某种意义上说，你已经知道如何处理“随时间变化的值”：它们被称为“变量”。R 中的变量表示值，它们可以随着时间的推移而变化，但它们的设计初衷并不是为了在它们变化时为你提供帮助。变量可以随着时间的推移而改变，但它们永远不会自动改变。
\subsection{函数呢？}
函数的问题在于每次运行函数都要进行重复的计算。即使计算成本很低，不必要地重复它并不是什么大问题，但仍然没有必要：如果输入没有改变，为什么我们需要重新计算输出？
\subsection{事件驱动编程}
由于变量和函数都不起作用，我们需要创建一些新的东西。在过去的几十年里，我们会直接跳到事件驱动编程。事件驱动编程是一种非常简单的范例：你注册将响应事件而执行的回调函数。事件驱动编程解决了不必要的计算问题，但它产生了一个新问题：你必须仔细跟踪哪些输入影响哪些计算。不久之后，你就开始在正确性（只要有任何变化就更新所有内容）与性能（尝试仅更新必要的部分，并希望不会错过任何边缘情况）之间进行权衡，因为两者都很难做到。
\subsection{响应式编程}
在 Shiny 中，我们使用 reactiveVal() 创造了一个响应值。响应式值具有特殊语法来用于获取其值（像零参数函数一样调用它）和设置其值（通过像单参数函数一样调用它来设置其值）。

响应式表达式有两个重要的属性：
\begin{itemize}
    \item 它很懒：在被调用之前它不会做任何工作。
    \item 它被缓存：它在第二次和后续调用时不会执行任何工作，因为它缓存了先前的结果。
\end{itemize}
我们将在\nameref{ch14}中回顾这些重要的属性。
\section{响应式编程简史}
如果你想了解有关其他语言的响应式编程的更多信息，了解一些历史可能会有所帮助。你可以在 40 多年前的第一个电子表格 VisiCalc 中看到响应式编程的起源：

\begin{quote}
    我想象了一块神奇的黑板，如果你擦掉一个数字并在上面写下一个新的东西，所有其他数字都会自动改变，就像用数字进行文字处理一样。\\——丹·布里克林
\end{quote}


电子表格与响应式编程密切相关：你使用公式声明单元格之间的关系，当一个单元格发生更改时，其所有依赖项都会自动更新。所以你可能已经在不知不觉中完成了一堆响应式编程！

虽然响应性的想法已经存在很长时间了，但直到 20 世纪 90 年代末，学术计算机科学才开始认真研究它们。响应式编程的研究是由 FRAN 启动的，功能响应式动画是一种新颖的系统，用于将随时间的变化和用户输入合并到函数式编程语言中。这催生了丰富的文献，但对编程实践影响甚微。

直到 2010 年代，响应式编程才通过 JavaScript UI 框架的快节奏世界迅速进入编程主流。Knockout、Ember和Meteor（Joe Cheng 对 Shiny 的个人灵感）等开创性框架表明，响应式编程可以使 UI 编程变得更加容易。在短短几年内，响应式编程已经通过 React、Vue.js 和 Angular 等非常流行的框架主导了 Web 编程，这些框架要么本质上是响应式的，要么被设计为与响应式后端协同工作。

值得记住的是，“响应式编程”是一个相当笼统的术语。虽然所有响应式编程库、框架和语言都广泛关注编写响应不断变化的值的程序，但它们在术语、设计和实现方面存在巨大差异。在本书中，每当我们提到“响应式编程”时，我们特指的是在 Shiny 中实现的响应式编程。因此，如果你阅读的响应式编程材料并非专门针对 Shiny，那么这些概念甚至术语不太可能与编写 Shiny 应用程序相关。对于对其他响应式编程框架有一定经验的读者来说，Shiny 的方法类似于 Meteor 和 MobX ，但与 ReactiveX 系列或任何标榜自己为函数式响应式编程的东西有很大不同。